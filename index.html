<!DOCTYPE html>
<html lang="en">
<head>
    <title>ARIS Rocket</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            overflow: hidden;
            color: white;
            font-family: consolas, mono;
        }


        #controls{
            position: fixed;
            top: 30px;
            left: 30px;

            font-size: 18px;
        }

        #altitude{
            font-size: 30px;
        }
    </style>
</head>
<body>

    <div id="controls">
        <p>
            Altitude1: <span id="altitude1"></span>
        </p>
        <p>
            Altitude2: <span id="altitude2"></span>
        </p>
        
        <button onclick="i = 0;">Restart</button>
    </div>

    <script src="./three.js"></script>
    <script src="./OrbitControls.js"></script>

    <script>
        var camera, scene, renderer;
        var rocket;
        var rocketOffset = new THREE.Vector3(0,0.9,0);
        var cameraOffset = new THREE.Vector3(1,2,4);
        var full;

        var rotdata;
        var i = 0;

        var line;

        var bgcol = 0x121214;

        init();
        //animate();

        var rotdata;

        var client = new XMLHttpRequest();
        client.responseType = 'json';
        client.open('GET', 'f.log');
        client.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                rotdata = client.response;
                animate();
            }
        }
        client.send();

        function init() {

            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );

            camera.position = rocketOffset;
            camera.position.add(cameraOffset);

            camera.rotation.set(-0.4,0,0);

            scene = new THREE.Scene();

            var light = new THREE.DirectionalLight({
                color: 0xffffff,
            });
            light.position.set(2,5,3);
            scene.add(light);

            rocket = new THREE.Group();
            rocket.scale.multiplyScalar(0.1);
            scene.add(rocket);

            var gridsize = 100;

            var gridHelper = new THREE.GridHelper( gridsize*10, gridsize, 0x888888, 0x444444 );
            scene.add( gridHelper );
            // var gridHelper2 = new THREE.GridHelper( gridsize*10, gridsize, 0x888888, 0x444444 );
            // scene.add( gridHelper2 );
            var gridHelper3 = new THREE.GridHelper( 10000000, 2, 0x888888, 0x444444 );
            scene.add( gridHelper3 );

            // var cubegeo = new THREE.BoxGeometry(2, 2, 2);
            // var mat = new THREE.MeshBasicMaterial({color: 0xcccccc});
            // var cube = new THREE.Mesh(cubegeo, mat);
            // cube.position.y = 1;
            // cube.position.z = -2;
            // scene.add(cube);

            controls = new THREE.OrbitControls(camera);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor( bgcol );
            document.body.appendChild( renderer.domElement );


            // var linegeo = new THREE.Geometry();
            // linegeo.vertices.push(
            // );
            // var line_material = new THREE.LineBasicMaterial({
            //     color: 0xffffff
            // });
            // line = new THREE.Line( linegeo, line_material );
            // line.scale.y = 0.06;
            // line.rotation.x = -Math.PI/2;

            // scene.add( line );
            //renderer.render( scene, camera );


            var bgmat = new THREE.MeshBasicMaterial({color: bgcol});
            var outlinemat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.BackSide
                });

            var loader = new THREE.JSONLoader();

            loader.load('models/fins.json', geometry => {
                var fins = new THREE.Mesh(geometry, bgmat);
                rocket.add(fins);

                renderer.render( scene, camera );
            });

            loader.load('models/finsoutline.json', geometry => {
                var finsoutline = new THREE.Mesh(geometry, outlinemat);
                rocket.add(finsoutline);
            });

            loader.load('models/body.json', geometry => {
                var body = new THREE.Mesh(geometry, bgmat);
                rocket.add(body);
            });

            loader.load('models/bodyoutline.json', geometry => {
                var bodyoutline = new THREE.Mesh(geometry, outlinemat);
                rocket.add(bodyoutline);
            });

            loader.load('models/exhaust.json', geometry => {
                var exhaust = new THREE.Mesh(geometry, bgmat);
                rocket.add(exhaust);
            });

            loader.load('models/exhaustoutline.json', geometry => {
                var exhaustoutline = new THREE.Mesh(geometry, outlinemat);
                rocket.add(exhaustoutline);
            });

            // loader.load('models/full.json', (geometry, material) => {
            //     full = new THREE.Mesh(geometry, material);
            //     scene.add(full);
            // });


            //
            window.addEventListener( 'resize', onWindowResize, false );
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }
        function animate() {
            requestAnimationFrame( animate );

            var rx, ry, rz, rw;
            var px, py, pz;

            [rx, ry, rz, rw] = rotdata.results[0].series[1].values[i].slice(1);
            [px, py, pz, pz2, pz2] = rotdata.results[0].series[0].values[i].slice(1);

            [px, py, pz, pz2] = [px || 0, py || 0, pz || 0, pz2 || 0];

            // everyone who ever decided in favour of a y-up coordinate system on anything should be arrested right now
            // https://www.gamedev.net/forums/topic/374728-quaternion-rotation-z-up-to-y-up/?do=findComment&comment=3471926

            document.getElementById('altitude1').innerHTML = pz.toFixed(2) + 'm';
            document.getElementById('altitude2').innerHTML = pz2.toFixed(2) + 'm';

            var quat = new THREE.Quaternion(rx, ry, rz, rw);

            quat.multiply(new THREE.Quaternion(0, 0, -0.7071, 0.7071));
            quat.premultiply(new THREE.Quaternion(-0.7071, 0, 0, 0.7071));

            rocket.quaternion.set(quat.x, quat.y, quat.z, quat.w);

            //console.log(px, py, pz);

            [px, py, pz] = [px, pz, -py];

            rocket.position.set(px, py, pz);
            rocket.position.add(rocketOffset);

            //camera.lookAt(px, py, pz);
            camera.position.set(px, py, pz);
            camera.position.add(cameraOffset);

            //rocket.quaternion.set(rx, ry, rz, rw);
            //console.log(rocket.quaternion);
            //rocket.applyQuaternion(new THREE.Quaternion(-0.7071, 0, 0, 0.7071));

            ++i;
            i%= rotdata.results[0].series[0].values.length;

            //line.rotation.z += 0.01

            //rocket.rotation.y += 0.015;
            //full.rotation.y += 0.015;
            // line.rotation.y += 0.01;
            renderer.render( scene, camera );
        }
    </script>

</body>
</html>