<!DOCTYPE html>
<html lang="en">
<head>
    <title>ARIS Rocket</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            overflow: hidden;
            color: white;
            font-family: consolas, mono;
        }


        #controls{
            position: fixed;
            top: 30px;
            left: 30px;

            font-size: 18px;
        }

        #altitude{
            font-size: 30px;
        }

        #textcanvas{
            display: none;
        }
    </style>
</head>
<body>

    <canvas id="textcanvas" width="200" height="50"></canvas>

    <div id="controls">
        <p>
            Altitude1: <span id="altitude1"></span>
        </p>
        <p>
            Altitude2: <span id="altitude2"></span>
        </p>
        
        <button onclick="i = 0;">Restart</button>
        <button onclick="animate();">Step</button>
    </div>

    <script src="./three.js"></script>
    <script src="./OrbitControls.js"></script>

    <script>
        var camera, scene, renderer;
        var rocket;
        var rockethud;
        var hudlines;

        var hudtext_ctx;
        var hudtext_canvas;

        var MAX_POINTS = 10000;

        // var font;
        // var textgeometry;
        // var textmesh;
        var rocketOffset = new THREE.Vector3(0,0.9,0);
        var cameraOffset = new THREE.Vector3(1,2,4);
        var full;

        var rotdata;
        var i = 0;

        var trajectory_line;

        var bgcol = 0x121214;

        init();
        //animate();

        var rotdata;

        var client = new XMLHttpRequest();
        client.responseType = 'json';
        client.open('GET', 'f.log');
        client.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                rotdata = client.response;
                animate();
            }
        }
        client.send();

        function init() {

            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );

            camera.position = rocketOffset;
            camera.position.add(cameraOffset);
            camera.rotation.set(-0.4,0,0);

            scene = new THREE.Scene();

            var light = new THREE.DirectionalLight({
                color: 0xffffff,
            });
            light.position.set(2,5,3);
            scene.add(light);

            rocket = new THREE.Group();
            rocket.scale.multiplyScalar(0.1);
            scene.add(rocket);

            hudlines = new THREE.Geometry();
            hudlines.vertices = [
                new THREE.Vector3(-.2,.2,0),
                new THREE.Vector3(-.6,.6,0),
                new THREE.Vector3(-1.5,.6,0)
            ];
            var line_material = new THREE.LineBasicMaterial({color: 0xffffff });

            rockethud = new THREE.Group();
            rockethud.add(new THREE.Line(hudlines, line_material));


            hudtext_canvas = document.getElementById("textcanvas");
            hudtext_ctx = hudtext_canvas.getContext("2d");
            
            hudtext_ctx.fillStyle = "white";
            hudtext_ctx.textAlign="end"; 
            hudtext_ctx.font = "40px Consolas, Mono";
            hudtext_ctx.fillText("120.00m",195,45);

            hudtext_texture = new THREE.CanvasTexture(hudtext_canvas);
            var hudtext_material = new THREE.MeshBasicMaterial({map:hudtext_texture, transparent: true});
            var textscale = 0.02;
            var hud = new THREE.Mesh(new THREE.PlaneGeometry(hudtext_canvas.width, hudtext_canvas.height), hudtext_material);
            hud.scale.multiplyScalar(0.005);
            hud.position.set(-1.1, 0.74, 0);

            rockethud.add(hud);

            scene.add(rockethud);

            var gridsize = 100;
            var gridHelper = new THREE.GridHelper( gridsize*10, gridsize, 0x888888, 0x444444 );
            scene.add( gridHelper );


            controls = new THREE.OrbitControls(camera);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor( bgcol );
            document.body.appendChild( renderer.domElement );


            var trajectory_line_geo = new THREE.BufferGeometry();
            var trajectory_line_positions = new Float32Array( MAX_POINTS * 3 ); // 3 values per vertex
            trajectory_line_geo.addAttribute( 'position', new THREE.BufferAttribute( trajectory_line_positions, 3 ) );
            trajectory_line = new THREE.Line(trajectory_line_geo, line_material);
            trajectory_line.position.set(rocketOffset.x, rocketOffset.y, rocketOffset.z);

            scene.add( trajectory_line );


            var bgmat = new THREE.MeshBasicMaterial({color: bgcol});
            var outlinemat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.BackSide
                });

            var loader = new THREE.JSONLoader();

            loader.load('models/fins.json', geometry => {
                var fins = new THREE.Mesh(geometry, bgmat);
                rocket.add(fins);

                renderer.render( scene, camera );
            });

            loader.load('models/finsoutline.json', geometry => {
                var finsoutline = new THREE.Mesh(geometry, outlinemat);
                rocket.add(finsoutline);
            });

            loader.load('models/body.json', geometry => {
                var body = new THREE.Mesh(geometry, bgmat);
                rocket.add(body);
            });

            loader.load('models/bodyoutline.json', geometry => {
                var bodyoutline = new THREE.Mesh(geometry, outlinemat);
                rocket.add(bodyoutline);
            });

            loader.load('models/exhaust.json', geometry => {
                var exhaust = new THREE.Mesh(geometry, bgmat);
                rocket.add(exhaust);
            });

            loader.load('models/exhaustoutline.json', geometry => {
                var exhaustoutline = new THREE.Mesh(geometry, outlinemat);
                rocket.add(exhaustoutline);
            });

            // loader.load('models/full.json', (geometry, material) => {
            //     full = new THREE.Mesh(geometry, material);
            //     scene.add(full);
            // });


            window.addEventListener( 'resize', onWindowResize, false );
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function updateHUD(text){
            hudtext_ctx.clearRect(0,0,hudtext_canvas.width, hudtext_canvas.height);
            hudtext_ctx.fillText(text, 195,45);
            hudtext_texture.needsUpdate = true;
        }



        function animate() {
            requestAnimationFrame( function(){} );

            var rx, ry, rz, rw;
            var px, py, pz;

            [rx, ry, rz, rw] = rotdata.results[0].series[1].values[i].slice(1);
            [px, py, pz, pz2, pz2] = rotdata.results[0].series[0].values[i].slice(1);

            [px, py, pz, pz2] = [px || 0, py || 0, pz || 0, pz2 || 0];

            // everyone who ever decided in favour of a y-up coordinate system on anything should be arrested right now
            // https://www.gamedev.net/forums/topic/374728-quaternion-rotation-z-up-to-y-up/?do=findComment&comment=3471926

            document.getElementById('altitude1').innerHTML = pz.toFixed(2) + 'm';
            document.getElementById('altitude2').innerHTML = pz2.toFixed(2) + 'm';

            updateHUD(pz.toFixed(2) + 'm');

            var quat = new THREE.Quaternion(rx, ry, rz, rw);

            quat.multiply(new THREE.Quaternion(0, 0, -0.7071, 0.7071));
            quat.premultiply(new THREE.Quaternion(-0.7071, 0, 0, 0.7071));

            rocket.quaternion.set(quat.x, quat.y, quat.z, quat.w);

            [px, py, pz] = [px, pz, -py];

            positions = trajectory_line.geometry.attributes.position.array;

            positions[i * 3] = px;
            positions[i * 3 + 1] = py;
            positions[i * 3 + 2] = pz;
            trajectory_line.geometry.setDrawRange(0, i);

            trajectory_line.geometry.attributes.position.needsUpdate = true;


            rocket.position.set(px, py, pz);
            rocket.position.add(rocketOffset);

            rockethud.position.set(px, py, pz);
            rockethud.position.add(rocketOffset);

            //camera.lookAt(px, py, pz);
            camera.position.set(px, py, pz);
            camera.position.add(cameraOffset);

            console.log(i);
            console.log(positions);
            console.log(trajectory_line.geometry.attributes.position);
            ++i;
            i%= rotdata.results[0].series[0].values.length;

            renderer.render( scene, camera );
        }
    </script>

</body>
</html>